import{g as S,at as C,q as b,aL as j,y as E,bd as M}from"./three.module-D7KO9fW1.js";const v=Symbol("TILE_X"),T=Symbol("TILE_Y"),L=Symbol("TILE_LEVEL");class R{get tiling(){return this.imageSource.tiling}constructor(e={}){const{pixelSize:i=.01,center:t=!1,useRecommendedSettings:o=!0,imageSource:n=null}=e;this.priority=-10,this.tiles=null,this.imageSource=n,this.pixelSize=i,this.center=t,this.useRecommendedSettings=o}init(e){this.useRecommendedSettings&&(e.errorTarget=1),this.tiles=e,this.imageSource.fetchOptions=e.fetchOptions,this.imageSource.fetchData=(i,t)=>(e.invokeAllPlugins(o=>i=o.preprocessURL?o.preprocessURL(i,null):i),e.invokeOnePlugin(o=>o!==this&&o.fetchData&&o.fetchData(i,t)))}async loadRootTileSet(){const{tiles:e,imageSource:i}=this;let t=e.rootURL;return e.invokeAllPlugins(o=>t=o.preprocessURL?o.preprocessURL(t,null):t),await i.init(t),this.getTileset(t)}async parseToMesh(e,i,t,o,n){const s=i[v],r=i[T],c=i[L],l=await this.imageSource.processBufferToTexture(e);this.imageSource.setData(s,r,c,l);let h=1,u=1,g=0,a=0,p=0;const m=i.boundingVolume.box;m&&([g,a,p]=m,h=m[3],u=m[7]);const d=new S(new C(2*h,2*u),new b({map:l,transparent:!0}));return d.position.set(g,a,p),d}preprocessNode(e){const{tiling:i}=this,t=i.maxLevel;e[L]<t&&e.parent!==null&&this.expandChildren(e)}disposeTile(e){const i=e[v],t=e[T],o=e[L];this.imageSource.release(i,t,o)}getTileset(e){const{tiling:i,tiles:t}=this,o=i.minLevel,{tileCountX:n,tileCountY:s}=i.getLevel(o),r=[];for(let l=0;l<n;l++)for(let h=0;h<s;h++){const u=this.createChild(l,h,o);u!==null&&r.push(u)}const c={asset:{version:"1.1"},geometricError:1e5,root:{refine:"REPLACE",geometricError:1e5,boundingVolume:this.createBoundingVolume(0,0,-1),children:r,[L]:-1,[v]:0,[T]:0}};return t.preprocessTileSet(c,e),c}getUrl(e,i,t){return this.imageSource.getUrl(e,i,t)}createBoundingVolume(e,i,t){const{center:o,pixelSize:n,tiling:s}=this,{pixelWidth:r,pixelHeight:c}=s.getLevel(s.maxLevel),[l,h,u,g]=t===-1?s.getFullBounds(!0):s.getTileBounds(e,i,t,!0);let a=(u-l)/2,p=(g-h)/2,m=l+a,d=h+p;return o&&(m-=.5,d-=.5),m*=r*n,a*=r*n,d*=c*n,p*=c*n,{box:[m,d,0,a,0,0,0,p,0,0,0,0]}}createChild(e,i,t){const{pixelSize:o,tiling:n}=this;if(!n.getTileExists(e,i,t))return null;const{pixelWidth:s,pixelHeight:r}=n.getLevel(n.maxLevel),{pixelWidth:c,pixelHeight:l}=n.getLevel(t);return{refine:"REPLACE",geometricError:o*(Math.max(s/c,r/l)-1),boundingVolume:this.createBoundingVolume(e,i,t),content:{uri:this.getUrl(e,i,t)},children:[],[v]:e,[T]:i,[L]:t}}expandChildren(e){const i=e[L],t=e[v],o=e[T];for(let n=0;n<2;n++)for(let s=0;s<2;s++){const r=this.createChild(2*t+n,2*o+s,i+1);r&&e.children.push(r)}}}function y(...x){return x.join("_")}class Y{constructor(){this.cache={},this.count=0,this.cachedBytes=0}fetchItem(){}disposeItem(){}getMemoryUsage(e){return 0}setData(...e){const{cache:i}=this,t=e.pop(),o=y(...e);if(o in i)throw new Error(`DataCache: "${o}" is already present.`);return this.cache[o]={abortController:new AbortController,result:t,count:1,bytes:this.getMemoryUsage(t)},this.count++,this.cachedBytes+=this.cache[o].bytes,t}lock(...e){const{cache:i}=this,t=y(...e);if(t in i)i[t].count++;else{const o=new AbortController,n={abortController:o,result:null,count:1,bytes:0};n.result=this.fetchItem(...e,o.signal).then(s=>(n.result=s,n.bytes=this.getMemoryUsage(s),this.cachedBytes+=n.bytes,s)),this.cache[t]=n,this.count++}return i[t].result}release(...e){const i=y(...e);this.releaseViaFullKey(i)}get(...e){const{cache:i}=this,t=y(...e);return t in i?i[t].result:null}dispose(){const{cache:e}=this;for(const i in e){const{abortController:t}=e[i];t.abort(),this.releaseViaFullKey(i,!0)}this.cache={}}releaseViaFullKey(e,i=!1){const{cache:t}=this;if(e in t){const o=t[e];if(o.count--,o.count===0||i){const{result:n,abortController:s}=o;s.abort(),n instanceof Promise?n.then(r=>this.disposeItem(r)).catch(()=>{}):this.disposeItem(n),delete t[e],this.count--,this.cachedBytes-=o.bytes}return!0}else throw new Error("DataCache: Attempting to release key that does not exist")}}function f(x,e,i){return Math.min(Math.max(x,e),i)}class I{get levelCount(){return this._levels.length}get maxLevel(){return this.levelCount-1}get minLevel(){const e=this._levels;for(let i=0;i<e.length;i++)if(e[i]!==null)return i;return-1}get rootBounds(){var e;return this._rootBounds??((e=this.projection)==null?void 0:e.getBounds())??[0,0,1,1]}get rootOrigin(){const e=this.rootBounds;return this._rootOrigin??[e[0],e[1]]}constructor(){this.flipY=!1,this.pixelOverlap=0,this._rootBounds=null,this._rootOrigin=null,this.projection=null,this._levels=[]}setLevel(e,i={}){const t=this._levels;for(;t.length<e;)t.push(null);const{tilePixelWidth:o=256,tilePixelHeight:n=256,tileCountX:s=2**e,tileCountY:r=2**e}=i,{pixelWidth:c=o*s,pixelHeight:l=n*r}=i;t[e]={tilePixelWidth:o,tilePixelHeight:n,pixelWidth:c,pixelHeight:l,tileCountX:s,tileCountY:r}}generateLevels(e,i,t,o={}){const{minLevel:n=0,tilePixelWidth:s=256,tilePixelHeight:r=256}=o,c=e-1,{pixelWidth:l=s*i*2**c,pixelHeight:h=r*t*2**c}=o;for(let u=n;u<e;u++){const g=e-u-1,a=Math.ceil(l*2**-g),p=Math.ceil(h*2**-g),m=Math.ceil(a/s),d=Math.ceil(p/r);this.setLevel(u,{tilePixelWidth:s,tilePixelHeight:r,pixelWidth:a,pixelHeight:p,tileCountX:m,tileCountY:d})}}getLevel(e){return this._levels[e]}setOrigin(e,i){this._rootOrigin=[e,i]}setBounds(e,i,t,o){this._rootBounds=[e,i,t,o]}setProjection(e){this.projection=e}getTileAtPoint(e,i,t,o=!1,n=!0){const{projection:s,flipY:r}=this,{tileCountX:c,tileCountY:l}=this.getLevel(t),h=1/c,u=1/l;s&&!o&&(e=s.convertLongitudeToProjection(e),i=s.convertLatitudeToProjection(i)),n&&(e=f(e,0,1),i=f(i,0,1));let g=Math.floor(e/h),a=Math.floor(i/u);return r&&(a=l-1-a),n&&(g=f(g,0,c-1),a=f(a,0,l-1)),[g,a]}getTilesInRange(e,i,t,o,n,s=!1,r=!0){const c=this.getTileAtPoint(e,i,n,s,r),l=this.getTileAtPoint(t,o,n,s,r);return this.flipY&&([c[1],l[1]]=[l[1],c[1]]),[...c,...l]}getTileExists(e,i,t){const[o,n,s,r]=this.rootBounds,[c,l,h,u]=this.getTileBounds(e,i,t);return!(c>=h||l>=u)&&c<=s&&l<=r&&h>=o&&u>=n}getFullBounds(e=!1){const{projection:i}=this,t=[...this.rootBounds];return i&&e&&(t[0]=i.convertLongitudeToProjection(t[0]),t[1]=i.convertLatitudeToProjection(t[1]),t[2]=i.convertLongitudeToProjection(t[2]),t[3]=i.convertLatitudeToProjection(t[3])),t}getTileBounds(e,i,t,o=!1){const{flipY:n,pixelOverlap:s,projection:r}=this,{tilePixelWidth:c,tilePixelHeight:l,pixelWidth:h,pixelHeight:u}=this.getLevel(t);let g=c*e-s,a=l*i-s,p=g+c+s*2,m=a+l+s*2;if(g=Math.max(g,0),a=Math.max(a,0),p=Math.min(p,h),m=Math.min(m,u),g=g/h,p=p/h,a=a/u,m=m/u,n){const B=(m-a)/2,P=1-(a+m)/2;a=P-B,m=P+B}const d=[g,a,p,m];return r&&!o&&(d[0]=r.convertProjectionToLongitude(d[0]),d[1]=r.convertProjectionToLatitude(d[1]),d[2]=r.convertProjectionToLongitude(d[2]),d[3]=r.convertProjectionToLatitude(d[3])),d}toNormalizedRange(e){const i=[...e],{projection:t}=this;return this.projection&&(i[0]=t.convertLongitudeToProjection(i[0]),i[1]=t.convertLatitudeToProjection(i[1]),i[2]=t.convertLongitudeToProjection(i[2]),i[3]=t.convertLatitudeToProjection(i[3])),i}clampToBounds(e,i=!1){const t=[...e],{projection:o}=this;if(i||!o)t[0]=f(t[0],0,1),t[1]=f(t[1],0,1),t[2]=f(t[2],0,1),t[3]=f(t[3],0,1);else{const[n,s,r,c]=o.getBounds();t[0]=f(t[0],n,r),t[1]=f(t[1],s,c),t[2]=f(t[2],n,r),t[3]=f(t[3],s,c)}return t}}class U extends Y{constructor(){super(),this.tiling=new I,this.fetchOptions={},this.fetchData=(...e)=>fetch(...e)}init(e){}async processBufferToTexture(e){const i=new Blob([e]),t=await createImageBitmap(i,{premultiplyAlpha:"none",colorSpaceConversion:"none",imageOrientation:"flipY"}),o=new j(t);return o.generateMipmaps=!1,o.colorSpace=E,o.needsUpdate=!0,o}getMemoryUsage(e){const{TextureUtils:i}=M;if(!i)return 0;const{format:t,type:o,image:n,generateMipmaps:s}=e,{width:r,height:c}=n,l=i.getByteLength(r,c,t,o);return s?l*4/3:l}fetchItem(...e){const i=this.getUrl(...e);return this.fetchData(i,this.fetchOptions).then(t=>t.arrayBuffer()).then(t=>this.processBufferToTexture(t))}disposeItem(e){e.dispose(),e.image instanceof ImageBitmap&&e.image.close()}getUrl(...e){}}export{R as I,U as T,I as a,L as b,v as c,T as d};
