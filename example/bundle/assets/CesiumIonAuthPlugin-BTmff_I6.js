import{t as Pt}from"./TilesRenderer-BBgP2cW1.js";import{P as Ut,b as It}from"./EPSGTilesPlugin-BLbCEnRQ.js";import{bb as St,aj as gt,M as Et,g as yt,l as J,ak as st,p as Ct,J as Vt,T as Mt,bc as Nt,w as zt,i as it,an as pt}from"./three.module-D7KO9fW1.js";import{L as Bt}from"./readMagicBytes-B3HEinov.js";import{E as Ft}from"./Ellipsoid-CsJ1QeYU.js";import{a as Gt}from"./TiledImageSource-ERPSo-Ic.js";class Ot{constructor(t={}){const{apiToken:e,autoRefreshToken:s=!1}=t;this.apiToken=e,this.autoRefreshToken=s,this.authURL=null,this._tokenRefreshPromise=null,this._bearerToken=null}async fetch(t,e){await this._tokenRefreshPromise;const s={...e};s.headers=s.headers||{},s.headers={...s.headers,Authorization:this._bearerToken};const o=await fetch(t,s);return o.status>=400&&o.status<=499&&this.autoRefreshToken?(await this.refreshToken(e),fetch(t,s)):o}refreshToken(t){if(this._tokenRefreshPromise===null){const e=new URL(this.authURL);e.searchParams.append("access_token",this.apiToken),this._tokenRefreshPromise=fetch(e,t).then(s=>{if(!s.ok)throw new Error(`CesiumIonAuthPlugin: Failed to load data with error code ${s.status}`);return s.json()}).then(s=>(this._bearerToken=`Bearer ${s.accessToken}`,this._tokenRefreshPromise=null,s))}return this._tokenRefreshPromise}}class Dt{constructor(){this.creditsCount={}}_adjustAttributions(t,e){const s=this.creditsCount,o=t.split(/;/g);for(let h=0,f=o.length;h<f;h++){const P=o[h];P in s||(s[P]=0),s[P]+=e?1:-1,s[P]<=0&&delete s[P]}}addAttributions(t){this._adjustAttributions(t,!0)}removeAttributions(t){this._adjustAttributions(t,!1)}toString(){return Object.entries(this.creditsCount).sort((e,s)=>{const o=e[1];return s[1]-o}).map(e=>e[0]).join("; ")}}function bt(U){let t=null;return Pt(U,e=>{if(e.content&&e.content.uri){const[,s]=e.content.uri.split("?");return t=new URLSearchParams(s).get("session"),!0}return!1}),t}class Ht{constructor({apiToken:t,autoRefreshToken:e=!1,logoUrl:s=null,useRecommendedSettings:o=!0}){this.name="GOOGLE_CLOUD_AUTH_PLUGIN",this.priority=-1/0,this.apiToken=t,this.autoRefreshToken=e,this.useRecommendedSettings=o,this.logoUrl=s,this.sessionToken=null,this.tiles=null,this._onLoadCallback=null,this._visibilityChangeCallback=null,this._tokenRefreshPromise=null,this._attributionsManager=new Dt,this._logoAttribution={value:"",type:"image",collapsible:!1},this._attribution={value:"",type:"string",collapsible:!0}}init(t){t!=null&&(t.resetFailedTiles(),t.rootURL==null&&(t.rootURL="https://tile.googleapis.com/v1/3dtiles/root.json"),this.useRecommendedSettings&&(t.parseQueue.maxJobs=10,t.downloadQueue.maxJobs=30,t.errorTarget=20),this.tiles=t,this._onLoadCallback=({tileSet:e})=>{this.sessionToken=bt(e.root),t.removeEventListener("load-tile-set",this._onLoadCallback)},this._visibilityChangeCallback=({tile:e,visible:s})=>{const o=e.cached.metadata.asset.copyright||"";s?this._attributionsManager.addAttributions(o):this._attributionsManager.removeAttributions(o)},t.addEventListener("load-tile-set",this._onLoadCallback),t.addEventListener("tile-visibility-change",this._visibilityChangeCallback))}getAttributions(t){this.tiles.visibleTiles.size>0&&(this.logoUrl&&(this._logoAttribution.value=this.logoUrl,t.push(this._logoAttribution)),this._attribution.value=this._attributionsManager.toString(),t.push(this._attribution))}preprocessURL(t){return t=new URL(t),/^http/.test(t.protocol)&&(t.searchParams.delete("key"),t.searchParams.append("key",this.apiToken),this.sessionToken!==null&&t.searchParams.append("session",this.sessionToken)),t.toString()}dispose(){const{tiles:t}=this;t.removeEventListener("load-tile-set",this._onLoadCallback),t.removeEventListener("tile-visibility-change",this._visibilityChangeCallback)}async fetchData(t,e){this._tokenRefreshPromise!==null&&(await this._tokenRefreshPromise,t=this.preprocessURL(t));const s=await fetch(t,e);return s.status>=400&&s.status<=499&&this.autoRefreshToken?(await this._refreshToken(e),fetch(this.preprocessURL(t),e)):s}_refreshToken(t){if(this._tokenRefreshPromise===null){const e=new URL(this.tiles.rootURL);e.searchParams.append("key",this.apiToken),this._tokenRefreshPromise=fetch(e,t).then(s=>{if(!s.ok)throw new Error(`GoogleCloudAuthPlugin: Failed to load data with error code: ${s.status}`);return s.json()}).then(s=>{this.sessionToken=bt(s.root),this._tokenRefreshPromise=null}),this._tokenRefreshPromise.catch(s=>{this.tiles.dispatchEvent({type:"load-error",tile:null,error:s,url:e})})}return this._tokenRefreshPromise}}function dt(U){return U>>1^-(U&1)}class jt extends Bt{constructor(...t){super(...t),this.fetchOptions.header={Accept:"application/vnd.quantized-mesh,application/octet-stream;q=0.9"}}loadAsync(...t){const{fetchOptions:e}=this;return e.header=e.header||{},e.header.Accept="application/vnd.quantized-mesh,application/octet-stream;q=0.9",e.header.Accept+=";extensions=octvertexnormals-watermask-metadata",super.loadAsync(...t)}parse(t){let e=0;const s=new DataView(t),o=()=>{const n=s.getFloat64(e,!0);return e+=8,n},h=()=>{const n=s.getFloat32(e,!0);return e+=4,n},f=()=>{const n=s.getUint32(e,!0);return e+=4,n},P=()=>{const n=s.getUint8(e);return e+=1,n},v=(n,r)=>{const u=new r(t,e,n);return e+=n*r.BYTES_PER_ELEMENT,u},V={center:[o(),o(),o()],minHeight:h(),maxHeight:h(),sphereCenter:[o(),o(),o()],sphereRadius:o(),horizonOcclusionPoint:[o(),o(),o()]},i=f(),x=v(i,Uint16Array),X=v(i,Uint16Array),p=v(i,Uint16Array),g=new Float32Array(i),L=new Float32Array(i),N=new Float32Array(i);let z=0,q=0,tt=0;const A=32767;for(let n=0;n<i;++n)z+=dt(x[n]),q+=dt(X[n]),tt+=dt(p[n]),g[n]=z/A,L[n]=q/A,N[n]=tt/A;const F=i>65536,G=F?Uint32Array:Uint16Array;F?e=Math.ceil(e/4)*4:e=Math.ceil(e/2)*2;const Y=f(),$=v(Y*3,G);let D=0;for(var Q=0;Q<$.length;++Q){const n=$[Q];$[Q]=D-n,n===0&&++D}const H=(n,r)=>L[r]-L[n],B=(n,r)=>-H(n,r),et=(n,r)=>g[n]-g[r],c=(n,r)=>-et(n,r),l=f(),I=v(l,G);I.sort(H);const S=f(),y=v(S,G);y.sort(et);const O=f(),j=v(O,G);j.sort(B);const k=f(),E=v(k,G);E.sort(c);const b={westIndices:I,southIndices:y,eastIndices:j,northIndices:E},w={};for(;e<s.byteLength;){const n=P(),r=f();if(n===1){const u=v(i*2,Uint8Array),_=new Float32Array(i*3);for(let T=0;T<i;T++){let a=u[2*T+0]/255*2-1,m=u[2*T+1]/255*2-1;const d=1-(Math.abs(a)+Math.abs(m));if(d<0){const C=a;a=(1-Math.abs(m))*vt(C),m=(1-Math.abs(C))*vt(m)}const R=Math.sqrt(a*a+m*m+d*d);_[3*T+0]=a/R,_[3*T+1]=m/R,_[3*T+2]=d/R}w.octvertexnormals={extensionId:n,normals:_}}else if(n===2){const u=r===1?1:256,_=v(u*u,Uint8Array);w.watermask={extensionId:n,mask:_,size:u}}else if(n===4){const u=f(),_=v(u,Uint8Array),T=new TextDecoder().decode(_);w.metadata={extensionId:n,json:JSON.parse(T)}}}return{header:V,indices:$,vertexData:{u:g,v:L,height:N},edgeIndices:b,extensions:w}}}function vt(U){return U<0?-1:1}const Lt=new J,ut=new pt,M=new J,nt=new J;class Xt extends jt{constructor(t=St){super(),this.manager=t,this.ellipsoid=new Ft,this.skirtLength=1e3,this.smoothSkirtNormals=!0,this.solid=!1,this.minLat=-Math.PI/2,this.maxLat=Math.PI/2,this.minLon=-Math.PI,this.maxLon=Math.PI}parse(t){const{ellipsoid:e,solid:s,skirtLength:o,smoothSkirtNormals:h,minLat:f,maxLat:P,minLon:v,maxLon:V}=this,{header:i,indices:x,vertexData:X,edgeIndices:p,extensions:g}=super.parse(t),L=new gt,N=new Et,z=new yt(L,N);z.position.set(...i.center);const q="octvertexnormals"in g,tt=X.u.length,A=[],F=[],G=[],Y=[];let $=0,D=0;for(let c=0;c<tt;c++)H(c,M),B(M.x,M.y,M.z,nt),F.push(M.x,M.y),A.push(...nt);for(let c=0,l=x.length;c<l;c++)G.push(x[c]);if(q){const c=g.octvertexnormals.normals;for(let l=0,I=c.length;l<I;l++)Y.push(c[l])}if(L.addGroup($,x.length,D),$+=x.length,D++,s){const c=A.length/3;for(let l=0;l<tt;l++)H(l,M),B(M.x,M.y,M.z,nt,-o),F.push(M.x,M.y),A.push(...nt);for(let l=x.length-1;l>=0;l--)G.push(x[l]+c);if(q){const l=g.octvertexnormals.normals;for(let I=0,S=l.length;I<S;I++)Y.push(-l[I])}L.addGroup($,x.length,D),$+=x.length,D++}if(o>0){const{westIndices:c,eastIndices:l,southIndices:I,northIndices:S}=p;let y;const O=et(c);y=A.length/3,F.push(...O.uv),A.push(...O.positions);for(let b=0,w=O.indices.length;b<w;b++)G.push(O.indices[b]+y);const j=et(l);y=A.length/3,F.push(...j.uv),A.push(...j.positions);for(let b=0,w=j.indices.length;b<w;b++)G.push(j.indices[b]+y);const k=et(I);y=A.length/3,F.push(...k.uv),A.push(...k.positions);for(let b=0,w=k.indices.length;b<w;b++)G.push(k.indices[b]+y);const E=et(S);y=A.length/3,F.push(...E.uv),A.push(...E.positions);for(let b=0,w=E.indices.length;b<w;b++)G.push(E.indices[b]+y);q&&(Y.push(...O.normals),Y.push(...j.normals),Y.push(...k.normals),Y.push(...E.normals)),L.addGroup($,x.length,D),$+=x.length,D++}for(let c=0,l=A.length;c<l;c+=3)A[c+0]-=i.center[0],A[c+1]-=i.center[1],A[c+2]-=i.center[2];const Q=A.length/3>65535?new Uint32Array(G):new Uint16Array(G);if(L.setIndex(new st(Q,1,!1)),L.setAttribute("position",new st(new Float32Array(A),3,!1)),L.setAttribute("uv",new st(new Float32Array(F),2,!1)),q&&L.setAttribute("normal",new st(new Float32Array(Y),3,!1)),"watermask"in g){const{mask:c,size:l}=g.watermask,I=new Uint8Array(2*l*l);for(let y=0,O=c.length;y<O;y++){const j=c[y]===255?0:255;I[2*y+0]=j,I[2*y+1]=j}const S=new Ct(I,l,l,Vt,Mt);S.flipY=!0,S.minFilter=Nt,S.magFilter=zt,S.needsUpdate=!0,N.roughnessMap=S}return z.userData.minHeight=i.minHeight,z.userData.maxHeight=i.maxHeight,"metadata"in g&&(z.userData.metadata=g.metadata.json),z;function H(c,l){return l.x=X.u[c],l.y=X.v[c],l.z=X.height[c],l}function B(c,l,I,S,y=0){const O=it.lerp(i.minHeight,i.maxHeight,I),j=it.lerp(v,V,c),k=it.lerp(f,P,l);return e.getCartographicToPosition(k,j,O+y,S),S}function et(c){const l=[],I=[],S=[],y=[],O=[];for(let E=0,b=c.length;E<b;E++)H(c[E],M),l.push(M.x,M.y),S.push(M.x,M.y),B(M.x,M.y,M.z,nt),I.push(...nt),B(M.x,M.y,M.z,nt,-o),y.push(...nt);const j=c.length-1;for(let E=0;E<j;E++){const b=E,w=E+1,n=E+c.length,r=E+c.length+1;O.push(b,n,w),O.push(w,n,r)}let k=null;if(q){const E=(I.length+y.length)/3;if(h){k=new Array(E*3);const b=g.octvertexnormals.normals,w=k.length/2;for(let n=0,r=E/2;n<r;n++){const u=c[n],_=3*n,T=b[3*u+0],a=b[3*u+1],m=b[3*u+2];k[_+0]=T,k[_+1]=a,k[_+2]=m,k[w+_+0]=T,k[w+_+1]=a,k[w+_+2]=m}}else{k=[],ut.a.fromArray(I,0),ut.b.fromArray(y,0),ut.c.fromArray(I,3),ut.getNormal(Lt);for(let b=0;b<E;b++)k.push(...Lt)}}return{uv:[...l,...S],positions:[...I,...y],indices:O,normals:k}}}clipToQuadrant(t,e,s){const o=new J,h=new J,f=new J,P=new J,v=new J,V=new J,i=new J,x=new J,X={},p=.5,g=new qt,L=["a","b","c"],{ellipsoid:N,skirtLength:z,solid:q,smoothSkirtNormals:tt}=this,A=t.geometry,F=A.attributes.normal,G=A.index;let Y=0;const $={},D=[],Q=F?[]:null,H=[],B=[],et=e?0:-.5,c=s?0:-.5,l=new gt,I=A.groups[0];let S=B.length,y=0;for(let n=I.start/3;n<(I.start+I.count)/3;n++){const r=G.getX(n*3+0),u=G.getX(n*3+1),_=G.getX(n*3+2),T=g.get();T.setFromAttributeAndIndices(A,r,u,_);const a=[];E(T,"x",e,a);const m=[];for(let K=0,ot=a.length;K<ot;K++)E(a[K],"y",s,m);const{minLat:d,maxLat:R,minLon:C,maxLon:lt,ellipsoid:Z}=this;for(let K=0,ot=m.length;K<ot;K++){const W=m[K];L.forEach(ft=>{const ct=W.uv[ft];if(ct.x!==p&&ct.y!==p)return;const ht=W.position[ft],kt=it.lerp(d,R,ct.y),Rt=it.lerp(C,lt,ct.x);ht.add(t.position),Z.getPositionToCartographic(ht,X),Z.getCartographicToPosition(kt,Rt,X.height,ht),ht.sub(t.position)}),w(W.position.a,W.uv.a,W.normal.a),w(W.position.b,W.uv.b,W.normal.b),w(W.position.c,W.uv.c,W.normal.c)}g.reset()}l.addGroup(S,B.length-S,y),y++;const O=B.length/3;if(q){S=B.length;for(let n=O*3-1;n>=0;n--){const r=B[n];i.fromArray(D,r*3).add(t.position),N.getPositionToNormal(i,i),f.fromArray(D,r*3).addScaledVector(i,-z),o.fromArray(H,r*2),i.fromArray(Q,r*3),w(f,o,i)}l.addGroup(S,B.length-S,y),y++}if(z>0){S=B.length;for(let n=0;n<O;n++){const r=3*n;for(let u=0;u<3;u++){const _=(u+1)%3,T=B[r+u],a=B[r+_];if(o.fromArray(H,T*2),h.fromArray(H,a*2),o.x===h.x&&(o.x===0||o.x===p||o.x===1)||o.y===h.y&&(o.y===0||o.y===p||o.y===1)){f.fromArray(D,T*3),P.fromArray(D,a*3);const m=f,d=P,R=v.copy(f),C=V.copy(P);i.copy(R).add(t.position),N.getPositionToNormal(i,i),R.addScaledVector(i,-z),i.copy(C).add(t.position),N.getPositionToNormal(i,i),C.addScaledVector(i,-z),tt&&Q?(i.fromArray(Q,T*3),x.fromArray(Q,a*3)):(i.subVectors(m,d),x.subVectors(m,R).cross(i).normalize(),i.copy(x)),w(d,h,x),w(m,o,i),w(R,o,i),w(d,h,x),w(R,o,i),w(C,h,x)}}}l.addGroup(S,B.length-S,y),y++}for(let n=0,r=H.length;n<r;n+=2)H[n]=(H[n]+et)*2,H[n+1]=(H[n+1]+c)*2;const j=D.length/3>65535?new Uint32Array(B):new Uint16Array(B);l.setIndex(new st(j,1,!1)),l.setAttribute("position",new st(new Float32Array(D),3,!1)),l.setAttribute("uv",new st(new Float32Array(H),2,!1)),F&&l.setAttribute("normal",new st(new Float32Array(Q),3,!1));const k=new yt(l,t.material.clone());return k.position.copy(t.position),k.quaternion.copy(t.quaternion),k.scale.copy(t.scale),k.userData.minHeight=t.userData.minHeight,k.userData.maxHeight=t.userData.maxHeight,k;function E(n,r,u,_){const T=[],a=[],m=[];for(let d=0;d<3;d++){const R=L[d],C=L[(d+1)%3],lt=n.uv[R],Z=n.uv[C],K=lt[r],ot=Z[r];(K<p!=ot<p||K===p)&&(T.push(d),a.push([R,C]),m.push(it.mapLinear(p,K,ot,0,1)))}if(T.length!==2)Math.min(n.uv.a[r],n.uv.b[r],n.uv.c[r])<p===u&&_.push(n);else if(T.length===2){const d=g.get(),R=g.get(),C=g.get();(T[0]+1)%3===T[1]?(d.lerpVertex(n,a[0][0],a[0][1],m[0],"a"),d.copyVertex(n,a[0][1],"b"),d.lerpVertex(n,a[1][0],a[1][1],m[1],"c"),d.uv.a[r]=p,d.uv.c[r]=p,R.lerpVertex(n,a[0][0],a[0][1],m[0],"a"),R.copyVertex(n,a[1][1],"b"),R.copyVertex(n,a[0][0],"c"),R.uv.a[r]=p,C.lerpVertex(n,a[0][0],a[0][1],m[0],"a"),C.lerpVertex(n,a[1][0],a[1][1],m[1],"b"),C.copyVertex(n,a[1][1],"c"),C.uv.a[r]=p,C.uv.b[r]=p):(d.lerpVertex(n,a[0][0],a[0][1],m[0],"a"),d.lerpVertex(n,a[1][0],a[1][1],m[1],"b"),d.copyVertex(n,a[0][0],"c"),d.uv.a[r]=p,d.uv.b[r]=p,R.lerpVertex(n,a[0][0],a[0][1],m[0],"a"),R.copyVertex(n,a[0][1],"b"),R.lerpVertex(n,a[1][0],a[1][1],m[1],"c"),R.uv.a[r]=p,R.uv.c[r]=p,C.copyVertex(n,a[0][1],"a"),C.copyVertex(n,a[1][0],"b"),C.lerpVertex(n,a[1][0],a[1][1],m[1],"c"),C.uv.c[r]=p);let Z;Z=Math.min(d.uv.a[r],d.uv.b[r],d.uv.c[r]),Z<p===u&&_.push(d),Z=Math.min(R.uv.a[r],R.uv.b[r],R.uv.c[r]),Z<p===u&&_.push(R),Z=Math.min(C.uv.a[r],C.uv.b[r],C.uv.c[r]),Z<p===u&&_.push(C)}}function b(n,r,u){const a=~~(n*1e5+.5),m=~~(r*1e5+.5),d=~~(u*1e5+.5);return`${a}_${m}_${d}`}function w(n,r,u){let _=b(n.x,n.y,n.z);Q&&(_+=`_${b(u.x,u.y,u.z)}`),_ in $||($[_]=Y,Y++,D.push(n.x,n.y,n.z),H.push(r.x,r.y),Q&&Q.push(u.x,u.y,u.z));const T=$[_];return B.push(T),T}}}class qt{constructor(){this.pool=[],this.index=0}get(){if(this.index>=this.pool.length){const e=new $t;this.pool.push(e)}const t=this.pool[this.index];return this.index++,t}reset(){this.index=0}}class $t{constructor(){this.position=new pt,this.uv=new pt,this.normal=new pt}setFromAttributeAndIndices(t,e,s,o){this.position.setFromAttributeAndIndices(t.attributes.position,e,s,o),this.uv.setFromAttributeAndIndices(t.attributes.uv,e,s,o),t.attributes.normal&&this.normal.setFromAttributeAndIndices(t.attributes.normal,e,s,o)}lerpVertex(t,e,s,o,h){this.position[h].lerpVectors(t.position[e],t.position[s],o),this.uv[h].lerpVectors(t.uv[e],t.uv[s],o),this.normal[h].lerpVectors(t.normal[e],t.normal[s],o)}copyVertex(t,e,s){this.position[s].copy(t.position[e]),this.uv[s].copy(t.uv[e]),this.normal[s].copy(t.normal[e])}}const At=Symbol("TILE_X"),wt=Symbol("TILE_Y"),at=Symbol("TILE_LEVEL"),rt=Symbol("TILE_AVAILABLE"),_t=1e4,xt=new J;function Qt(U,t,e,s){if(t<U.length){const o=U[t];for(let h=0,f=o.length;h<f;h++){const{startX:P,startY:v,endX:V,endY:i}=o[h];if(e>=P&&e<=V&&s>=v&&s<=i)return!0}}return!1}function Tt(U){const{available:t=null,maxzoom:e=null}=U;return e===null?t.length-1:e}function Yt(U){const{metadataAvailability:t=-1}=U;return t}function mt(U,t){const e=U[at],s=Yt(t),o=Tt(t);return e<o&&s!==-1&&e%s===0}function Jt(U,t,e,s,o){return o.tiles[0].replace(/{\s*z\s*}/g,e).replace(/{\s*x\s*}/g,U).replace(/{\s*y\s*}/g,t).replace(/{\s*version\s*}/g,s)}class Zt{constructor(t={}){const{useRecommendedSettings:e=!0,skirtLength:s=null,smoothSkirtNormals:o=!0,solid:h=!1}=t;this.name="QUANTIZED_MESH_PLUGIN",this.tiles=null,this.layer=null,this.useRecommendedSettings=e,this.skirtLength=s,this.smoothSkirtNormals=o,this.solid=h,this.attribution=null,this.tiling=new Gt,this.projection=new Ut}init(t){t.fetchOptions.headers=t.fetchOptions.headers||{},t.fetchOptions.headers.Accept="application/vnd.quantized-mesh,application/octet-stream;q=0.9",this.useRecommendedSettings&&(t.errorTarget=2),this.tiles=t}loadRootTileSet(){const{tiles:t}=this;let e=new URL("layer.json",new URL(t.rootURL,location.href));return t.invokeAllPlugins(s=>e=s.preprocessURL?s.preprocessURL(e,null):e),t.invokeOnePlugin(s=>s.fetchData&&s.fetchData(e,this.tiles.fetchOptions)).then(s=>s.json()).then(s=>{this.layer=s;const{projection:o="EPSG:4326",extensions:h=[],attribution:f="",available:P=null}=s,{tiling:v,tiles:V,projection:i}=this;f&&(this.attribution={value:f,type:"string",collapsible:!0}),h.length>0&&(V.fetchOptions.headers.Accept+=`;extensions=${h.join("-")}`),i.setScheme(o);const{tileCountX:x,tileCountY:X}=i;v.setProjection(i),v.generateLevels(Tt(s)+1,x,X);const p=[];for(let N=0;N<x;N++){const z=this.createChild(0,N,0,P);z&&p.push(z)}const g={asset:{version:"1.1"},geometricError:1/0,root:{refine:"REPLACE",geometricError:1/0,boundingVolume:{region:[...this.tiling.getFullBounds(),-1e4,_t]},children:p,[rt]:P,[at]:-1}};let L=V.rootURL;return V.invokeAllPlugins(N=>L=N.preprocessURL?N.preprocessURL(L,null):L),V.preprocessTileSet(g,L),g})}async parseToMesh(t,e,s,o){const{skirtLength:h,solid:f,smoothSkirtNormals:P,tiles:v}=this,V=v.ellipsoid,i=new Xt(v.manager);i.ellipsoid.copy(V),i.solid=f,i.smoothSkirtNormals=P,i.skirtLength=h===null?e.geometricError:h;let x;if(s==="tile_split"){const L=new URL(o).searchParams,N=L.get("left")==="true",z=L.get("bottom")==="true",[q,tt,A,F]=e.parent.boundingVolume.region;i.minLat=tt,i.maxLat=F,i.minLon=q,i.maxLon=A,x=i.clipToQuadrant(e.parent.cached.scene,N,z)}else{const[L,N,z,q]=e.boundingVolume.region;i.minLat=N,i.maxLat=q,i.minLon=L,i.maxLon=z,x=i.parse(t)}const{minHeight:X,maxHeight:p,metadata:g}=x.userData;return e.boundingVolume.region[4]=X,e.boundingVolume.region[5]=p,e.cached.boundingVolume.setRegionData(V,...e.boundingVolume.region),g&&("geometricerror"in g&&(e.geometricError=g.geometricerror),mt(e,this.layer)&&"available"in g&&e.children.length===0&&(e[rt]=[...new Array(e[at]+1).fill(null),...g.available])),this.expandChildren(e),x}getAttributions(t){this.attribution&&t.push(this.attribution)}createChild(t,e,s,o){const{tiles:h,layer:f,tiling:P,projection:v}=this,V=h.ellipsoid,i=o===null||Qt(o,t,e,s),x=Jt(e,s,t,1,f),X=[...P.getTileBounds(e,s,t),-1e4,_t],[,p,,g,,L]=X,N=p>0!=g>0?0:Math.min(Math.abs(p),Math.abs(g));V.getCartographicToPosition(N,0,L,xt),xt.z=0;const z=v.tileCountX,A=Math.max(...V.radius)*2*Math.PI*.25/(65*z)/2**t,F={[rt]:null,[at]:t,[At]:e,[wt]:s,refine:"REPLACE",geometricError:A,boundingVolume:{region:X},content:i?{uri:x}:null,children:[]};return mt(F,f)||(F[rt]=o),F}expandChildren(t){const e=t[at],s=t[At],o=t[wt],h=t[rt];let f=!1;for(let P=0;P<2;P++)for(let v=0;v<2;v++){const V=this.createChild(e+1,2*s+P,2*o+v,h);V.content!==null?(t.children.push(V),f=!0):(t.children.push(V),V.content={uri:`tile.tile_split?bottom=${v===0}&left=${P===0}`})}f||(t.children.length=0)}fetchData(t,e){if(/tile_split/.test(t))return new ArrayBuffer}disposeTile(t){mt(t,this.layer)&&(t.children.length=0,t.__childrenProcessed=0,t[rt]=null),t.children.length=0,t.__childrenProcessed=0}}class oe{get apiToken(){return this.auth.apiToken}set apiToken(t){this.auth.apiToken=t}get autoRefreshToken(){return this.auth.autoRefreshToken}set autoRefreshToken(t){this.auth.autoRefreshToken=t}constructor({apiToken:t,assetId:e=null,autoRefreshToken:s=!1,useRecommendedSettings:o=!0}){this.name="CESIUM_ION_AUTH_PLUGIN",this.priority=-1/0,this.auth=new Ot({apiToken:t,autoRefreshToken:s}),this.assetId=e,this.autoRefreshToken=s,this.useRecommendedSettings=o,this.tiles=null,this._tileSetVersion=-1,this._attributions=[]}init(t){this.assetId!==null&&(t.rootURL=`https://api.cesium.com/v1/assets/${this.assetId}/endpoint`),this.tiles=t,this.auth.authURL=t.rootURL,t.resetFailedTiles()}loadRootTileSet(){return this.auth.refreshToken().then(t=>(this._initializeFromAsset(t),this.tiles.invokeOnePlugin(e=>e!==this&&e.loadRootTileSet&&e.loadRootTileSet()))).catch(t=>{this.tiles.dispatchEvent({type:"load-error",tile:null,error:t,url:this.auth.authURL})})}preprocessURL(t){return t=new URL(t),/^http/.test(t.protocol)&&this._tileSetVersion!=-1&&t.searchParams.append("v",this._tileSetVersion),t.toString()}fetchData(t,e){return this.tiles.getPluginByName("GOOGLE_CLOUD_AUTH_PLUGIN")!==null?null:this.auth.fetch(t,e)}getAttributions(t){this.tiles.visibleTiles.size>0&&t.push(...this._attributions)}_initializeFromAsset(t){const e=this.tiles;if("externalType"in t){const s=new URL(t.options.url);e.rootURL=t.options.url,e.registerPlugin(new Ht({apiToken:s.searchParams.get("key"),autoRefreshToken:this.autoRefreshToken,useRecommendedSettings:this.useRecommendedSettings}))}else{t.type==="TERRAIN"&&e.getPluginByName("QUANTIZED_MESH_PLUGIN")===null?e.registerPlugin(new Zt({useRecommendedSettings:this.useRecommendedSettings})):t.type==="IMAGERY"&&e.getPluginByName("TMS_TILES_PLUGIN")===null&&e.registerPlugin(new It({useRecommendedSettings:this.useRecommendedSettings,shape:"ellipsoid"})),e.rootURL=t.url;const s=new URL(t.url);s.searchParams.has("v")&&this._tileSetVersion===-1&&(this._tileSetVersion=s.searchParams.get("v")),t.attributions&&(this._attributions=t.attributions.map(o=>({value:o.html,type:"html",collapsible:o.collapsible})))}}}export{oe as C,Ot as a};
